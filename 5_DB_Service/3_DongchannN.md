## NoSQL 데이터베이스의 특징

### 기본 특성

- 초당 수만 회 이상의 데이터 트랜잭션을 일관되게 처리할 수 있도록 설계됨
- 비구조화 데이터를 저장하는 데 최적화된 데이터베이스 모델
- 스키마가 없거나 유연한 스키마를 제공하여 다양한 형태의 데이터 저장 가능

### 데이터 구조

- 컬렉션(collections)이라는 요소로 구성됨, 이는 테이블로도 불림
- 다중 구조(multi-structured) 데이터 처리 가능
- 데이터가 다양한 구조를 갖고 있으며, 시간 경과에 따라 구조가 바뀔 수 있음
	- 테이블 내의 모든 아이템이 동일한 속성을 지닐 필요도 없음

### 데이터 저장 방식

- 아이템(item)을 저장하며, 이는 관계형 데이터베이스의 로우/튜플과 유사
- 각 아이템은 테이블 내에서 유일한 값을 지닌 기본 키 속성을 지님
	- 아이템 식별 및 정렬 시 사용
- 각 아이템은 하나 이상의 속성(attribute)으로 구성됨, 이는 관계형 데이터베이스의 컬럼과 유사
- 속성은 키/밸류 쌍(key/value pairs)으로 표현됨

![NoSql img](./images/NoSQL%20example.png)


### NoSQL의 성능 특성

#### 쿼리와 데이터 접근

- 키를 기준으로 한 쿼리 작업에 최적화됨
- 키가 아닌 다른 속성으로 쿼리 시 속도가 느려짐
- 쓰기 작업에는 적합하지만, 복잡한 읽기/조인 작업에는 상대적으로 약점 있음

#### 데이터 관계 처리

- 테이블에서 쿼리 작업을 위한 데이터 분할, 병합 기능을 제공하지 않음
- 애플리케이션이 테이블 내에서 데이터의 변경 내용을 지속적으로 추적해야 함
	- 이는 데이터의 의도치 않은 복제 문제로 이어질 수 있음

**조금 더 자세히**
- **관계형 DB에서의 자동 추적**:
    - 외래 키와 조인으로 데이터 관계 자동 유지
    - 원본 데이터 변경 시 조인 쿼리가 항상 최신 데이터 반영
    - 트랜잭션과 무결성 제약조건으로 데이터 일관성 보장
- **NoSQL에서의 수동 추적**:
    - 데이터 간 관계는 개발자가 직접 관리
    - 중복 저장 방식 사용 시 원본 데이터 변경될 때 모든 복제본 업데이트 필요
    - 이러한 "데이터 변경 추적" 로직은 애플리케이션 코드에서 구현해야 함
- **트레이드오프**:
    - 관계형 DB: 데이터 일관성 강점, 수직적 확장 제한
    - NoSQL: 확장성과 성능 강점, 데이터 일관성 관리에 추가 개발 필요

#### 조회 최적화

- 복잡한 쿼리 작업에는 적합하지 않으나 키 기반 조회는 매우 빠름
- 보조 인덱스를 통해 추가적인 접근 패턴 지원 가능
ex) "사용자 ID로 최신 게시물 20개 조회", "점수 업데이트와 순위 조회"


**데이터베이스 선택 시 고려 사항**
1. **데이터 구조와 관계**
    - 복잡한 관계가 많고 정규화가 필요 → 관계형 DB
    - 단순하거나 계층적 데이터, 유연한 스키마가 필요 → NoSQL
2. **쿼리 패턴**
    - 복잡한 조인, 집계, 분석이 필요 → 관계형 DB
    - 단순한 키 기반 조회, 대량 읽기/쓰기가 필요 → NoSQL
3. **확장성 요구사항**
    - 수직적 확장으로 충분 → 관계형 DB 가능
    - 수평적 확장이 필요한 대규모 서비스 → NoSQL 유리
4. **일관성 vs 가용성**
    - 강한 일관성, ACID 트랜잭션이 중요 → 관계형 DB
    - 고가용성, 분산 처리가 우선 → NoSQL


---
## DynamoDB

- AWS에서 제공하는 NoSQL 데이터베이스 서비스
- 파티션(partition)이라는 저장 영역을 사용하여 데이터 분산 저장, 다수의 AZ에 존재하는 SSD 장치 이용
- SSD 기반 스토리지로 높은 성능 제공

### 키

#### 파티션 키(Partition Key)

- 파티션 키는 해시 키라고도 불리며, 하나의 값을 지닌 기본 키입니다.
- 데이터가 저장될 물리적 위치(파티션)를 결정합니다.
- 효율적인 액세스를 위해 고르게 분산되는 값을 선택하는 것이 중요합니다.

#### 정렬 키(Sort Key)

- 범위 키(Range Key)라고도 불림
- 같은 파티션 내 항목들을 정렬하는 기준이 됨

#### 키 유형

1. **단순 기본 키(Simple Primary Key)**
    - 파티션 키만 사용하는 경우
    - 테이블 내 각 항목은 고유한 파티션 키 값을 가져야 함
    - 예: 사용자 ID, 제품 코드 등
2. **복합 기본 키(Composite Primary Key)**
    - 파티션 키와 정렬 키(Sort Key)의 조합
    - 동일한 파티션 키를 가진 여러 항목이 있을 수 있음
    - 파티션 키 + 정렬 키의 조합은 테이블 내에서 고유해야 함
    - 정렬 키는 같은 파티션 내 항목들의 순서를 결정

**핫 파티션**
- "성능 저하의 원인"이 되는 파티션
- 특정 파티션에 트래픽이 집중될 때 발생
- 파티션 키를 가능한 한 세분화하여 지정하는 것이 좋음
- 예: 로그 엔트리를 저장할 때 타임스탬프를 파티션 키로 사용하면 너무 세밀한 시간 단위로 인해 핫 파티션이 생길 수 있음
- 더 넓은 시간 범위(예: 일별)와 ID를 조합한 복합 키를 사용하면 부하를 분산할 수 있음

### 데이터 타입

너무 개념적인 부분은 책을 통해 확인

### 처리용량

- 프로비저닝: 미리 정의된 읽기/쓰기 용량 단위 설정
- 온디맨드 모드: 사용한 만큼만 비용 지불하는 자동 확장 방식
- 자동 스케일링: 트래픽에 따라 처리량 자동 조정

#### 읽기 용량 단위(RCU)와 쓰기 용량 단위(WCU)

**읽기 용량 단위(RCU)**: DynamoDB에서 초당 수행할 수 있는 읽기 작업의 수
**쓰기 용량 단위(WCU)**: DynamoDB에서 초당 수행할 수 있는 쓰기 작업의 수

이 용량 단위들은 DynamoDB 테이블이 처리할 수 있는 트래픽의 양을 결정하며, 테이블을 생성할 때 설정

**용량 단위 계산**
1. **읽기 용량 단위(RCU)**:
    - 1 RCU = 초당 최대 4KB 크기의 아이템을 강한 일관성으로 읽을 수 있음
    - 최종적 일관성 읽기를 사용할 경우, 1 RCU로 초당 최대 8KB 크기의 아이템을 읽을 수 있음 (강한 일관성 읽기의 2배 효율)
    - 아이템 크기가 4KB를 초과하면 추가 RCU가 필요함 (예: 6KB 아이템은 강한 일관성 읽기 시 2 RCU 필요)
2. **쓰기 용량 단위(WCU)**:
    - 1 WCU = 초당 최대 1KB 크기의 아이템을 쓸 수 있음
    - 예: 1KB 미만인 100개의 아이템을 저장하려면 100 WCU 필요
    - 2KB 크기의 10개 아이템을 저장하려면 20 WCU 필요 (아이템당 2 WCU)

### 데이터 읽기 방식

DynamoDB는 데이터를 효율적으로 읽고 검색하기 위한 여러 방법을 제공
#### 스캔과 쿼리

**스캔(Scan)**
- 테이블 내 모든 아이템을 반환하는 연산
- 가장 비효율적인 읽기 방식으로, 전체 테이블을 탐색
- 많은 읽기 용량을 소모하며 대규모 테이블에서는 성능 저하
- 필터 표현식을 사용해 결과를 줄일 수 있으나, 읽기 용량 소모는 동일함

**쿼리(Query)**
- 특정 파티션 키 값에 따라 아이템을 반환
- 스캔보다 효율적
- 파티션 키와 정렬 키를 함께 사용하면 결과를 더 정확하게 필터링 가능

#### 읽기 유형

쿼리 실행 시 파티션 키가 정확하게 일치하는 아이템만 반환.
소트 키가 있는 경우 유연한 작업 가능
- 범위로 검색
- 키보다 큰/작은 값 검색
- 기타 다양한 비교 연산 가능

#### 보조 인덱스란

- 보조 인덱스는 테이블의 데이터를 다른 방식으로 찾을 수 있게 해주는 추가 검색 경로.

**예시**
- 원래 테이블은 기본 키(예: userId)로만 데이터를 빠르게 찾을 수 있음.
- 다른 필드(예: 이메일, 전화번호)로 검색하려면 보조 인덱스 필요.

**지역 보조 인덱스(LSI)**
- 테이블과 **동일한 파티션 키**를 사용하지만, **다른 정렬 키**를 사용
- 테이블 생성 시에만 만들 수 있고, 나중에 추가/삭제 불가능
- 각 파티션마다 크기가 10GB로 제한됨

**전역 보조 인덱스(GSI)**
- 테이블과 **완전히 다른 키**를 사용 가능 (파티션 키도 다를 수 있음)
- 테이블 생성 후에도 언제든지 추가/삭제 가능
- 크기 제한 없음

#### 전역 테이블(Global Tables)

- 전역 테이블은 여러 지역(리전)에 동일한 데이터를 자동으로 복제해주는 기능입니다.
- 강한 일관성 읽기는 지원하지 않음

**사용 이유**
1. **글로벌 접근성**: 전 세계 어디서나 빠른 응답 시간 (가까운 리전에서 데이터 제공)
2. **재해 복구**: 한 리전에 문제가 생겨도 다른 리전에서 서비스 계속 가능
3. **지역적 규제 준수**: 특정 국가의 데이터는 해당 국가 내에 저장 필요

### 백업

- 언제든 가능
- RCU를 소모하지 않고 DynamoDB의 성능에 영향을 주지 않음
- 백업 횟수에는 제한이 없으며, 동일 리전은 물론 다른 리전의 테이블로도 복원 가능
