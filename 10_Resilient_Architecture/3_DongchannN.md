## SQS (Simple Queue Service)

애플리케이션을 구성하는 다양한 컴포넌트가 서로에게 메시지를 전송할 수 있도록 돕는 AWS의 관리형 메시지 서비스

### 기본 역할

**프로듀서 컴포넌트**: 메시지를 생성하며, 큐에 메시지를 넣음  
**컨슈머 컴포넌트**: 큐에 있는 메시지를 읽음

### 기본 메시지 처리 방식

1. **SendMessage** 액션을 통해 큐에 하나 이상의 메시지를 넣음
    - 큐에 입력된 메시지는 인플라이트 메시지라고 함
2. 컨슈머는 **ReceiveMessage** 액션을 통해 하나 이상의 메시지를 소비
3. 메시지 처리 후 컨슈머는 **DeleteMessage** 액션을 통해 큐에서 삭제

### 주요 특징

#### 가시성 중지기간 (Visibility Timeout)

컨슈머가 큐에서 메시지를 확인하고 삭제하지 않으면 메시지는 큐에 유지됩니다. 하지만 확인된 메시지는 일정 시간 동안 다른 컨슈머가 확인할 수 없습니다.

- **목적**: 중복 처리 방지
- **기본값**: 30초
- **설정 범위**: 최소 0초, 최대 12시간

**가시성 중지기간이 문제가 되는 경우**:

- 메시지 처리 시간이 가시성 중지기간보다 긴 경우
- 컨슈머가 메시지를 받은 후 처리 중 장애가 발생한 경우
- 이런 상황에서는 메시지가 다시 큐에 나타나 중복 처리될 수 있음

#### 보유 기간 (Message Retention Period)

메시지가 큐에 영구적으로 있는 것은 아닙니다.

- **기본값**: 4일
- **설정 범위**: 최소 1분, 최대 14일

#### 딜레이 큐와 메시지 타이머

**딜레이 큐**: 큐에 메시지를 넣을 때 큐마다 지연 시간을 설정할 수 있음  
**메시지 타이머**: 개별 메시지에 대해 지연 시간을 설정할 수 있음

- 메시지 타이머를 설정한 경우 딜레이 큐 설정을 무시함
- **기본값**: 0초
- **최대**: 15분

**딜레이가 필요한 경우**:

- 주문 처리 후 일정 시간 후 확인 메시지 발송
- 배치 작업을 특정 시간에 실행하도록 스케줄링
- 시스템 부하 분산을 위한 메시지 처리 시간 조절
- 재시도 로직에서 백오프(backoff) 구현

### 큐 타입

큐의 성능과 작동 방식은 애플리케이션의 성능에 직접적인 영향을 끼칩니다.

#### 스탠다드 큐

- 메시지는 순서와 무관하게 전달됨
- 동일한 메시지가 중복되어 전달되는 경우도 있음
- 애플리케이션은 동일한 메시지에 대한 중복 처리 기능을 갖춰야 함
- 기본 큐 타입
- 최대 12만 개의 인플라이트 메시지 처리 가능

#### FIFO 큐

- 메시지 도착 순서대로 큐에 전달
- 중복 메시지 문제를 피할 수 있음
- 약 2만 개의 인플라이트 메시지 처리 가능

**메시지 그룹 기능**:

- 프로듀서별 메시지 순서 관리 가능
- 컨슈머가 큐에서 메시지를 꺼낼 때 메시지 그룹별로 순서에 맞게 확인 가능
- 실무적으로는 서로 다른 큐를 생성하여 사용하는 경우가 많음

### 폴링 (Polling)

메시지 도착 여부를 조회하는 옵션입니다.

#### 롱폴링 (Long Polling)

**사용 시기**: 약간의 지연이 있더라도 큐에 모든 메시지를 정확하게 확인해야 할 때

**특징**:

- 큐에서 대기 중인 모든 메시지를 반환
- 모든 큐 서버를 확인하므로 응답 시간이 최대 20초가량 걸릴 수 있음
- 숏폴링에 비해 조회 빈도수가 적으므로 더 경제적인 옵션
- 메시지가 없을 때는 최대 20초까지 대기하다가 메시지가 도착하면 즉시 반환

#### 숏폴링 (Short Polling)

**사용 시기**: 일부 메시지 누락이 있더라도 즉시 메시지를 확인해야 할 때

**특징**:

- 사용 가능한 서버 중 일부만 확인하여 대기 중인 메시지 내역만 즉시 반환
- 지연 시간이 짧음
- 큐에 메시지가 있는 상황에서도 메시지가 없다는 응답을 받을 수 있음
    - 이는 SQS가 분산 시스템이기 때문에 모든 서버를 확인하지 않아서 발생
- 모든 메시지를 누락 없이 확인하려면 여러 번 조회해야 함

**숏폴링에서 메시지 누락이 발생하는 이유**:

- SQS는 여러 서버에 분산되어 있음
- 숏폴링은 성능을 위해 일부 서버만 확인
- 확인하지 않은 서버에 메시지가 있을 수 있어 "메시지 없음" 응답을 받을 수 있음

### 데드레터 큐 (Dead Letter Queue)

컨슈머가 제대로 처리하지 못한 메시지를 별도로 관리하는 기능입니다.

#### 동작 원리

처리 시도 후 계속된 실패 시 메시지는 큐에서 벗어날 수 있습니다. 이를 데드레터라고 하며, 이런 메시지를 큐에서 꺼내 데드레터 큐에 따로 보관할 수 있습니다.

#### 설정 방법

1. 데드레터 큐 설정을 위해 소스 큐와 같은 큐 타입으로 생성
2. **maxReceiveCount** 속성을 이용해 메시지의 최대 인출 시도 횟수 설정
3. 데드레터 큐는 소스 큐와 동일한 리전에 있어야 함

#### 주의사항

- 데드레터 큐도 보유 기간의 영향을 받음
- 데드레터 큐에 옮겨진 시점이 아닌 **원본 생성 일자**를 기준으로 삭제됨
- 따라서 데드레터 큐의 보유 기간을 소스 큐보다 길게 설정하는 것이 좋음

---
## 가용성 고려 설계

가용성을 높이기 위해 더 많은 리소스를 프로비전할수록 복잡성은 높아지고 비용은 더 많이 발생함. 가용성을 극대화하는 것에만 초점을 두는 것이 아닌 가용성 요구 수준과 비용의 균형점을 도출할 수 있어야 함.

가용성 99%, 99.9%, 99.99%를 달성하기 위한 방법을 알아볼 것임

### 99%의 가용성을 위한 설계

- 99%의 가용성, 연간 3.5일의 다운타임 목표
- 이 때의 다운타임은 업청나게 큰 고통까지는 아니지만 많은 불편을 초래하는 수준

#### 아키텍처 구성

- 애플리케이션 및 셀프호스팅 SQL 데이터베이스를 실행하기 위해 단일 EC2 인스턴스 사용
- 데이터 백업을 위해 버저닝 기능이 활성화된 S3 버킷에 자동으로 데이터베이스가 백업되도록 스크립트 실행
- S3 Lifecycle 정책을 설정해 구 버전의 데이터는 Glacier로 이동 및 저장

#### 헬스 체크 및 장애 대응

- Route 53의 헬스 체크 기능으로 애플리케이션의 HTTP 200 OK 상태 코드를 확인
- Route 53 페일오버 레코드 세트를 생성해 헬스 체크를 통과한 경우 사용자에게 애플리케이션 서비스를 제공
- 헬스 체크를 통과하지 못한 경우 사용자에게 정적 실패 안내 웹페이지를 제공
    - 정적 웹페이지는 S3 버킷의 정적 웹사이트 호스팅을 이용하여 CloudFront 배포 호스팅을 이용해서 제공

#### 복원 절차

복원 절차는 정기적으로 확인해 정상 작동 여부 및 복원 소요 시간을 파악해야 함.

- 단순히 SQL 덤프 데이터를 생성해서 S3 버킷에 전송하는 실험으로는 부족함
- 정기적으로 새 인스턴스를 생성해서 백업을 이용해 정상적으로 데이터베이스를 복원할 수 있는지 확인해야 함

#### 가용성 계산

- 실패 상황 발생 시 복원 프로세스 시작 전 30분간 분석 및 결정 시간
- CloudFormation 이용 새 인스턴스 생성 10분 소요
- 데이터베이스 복원 30분 소요
- 실패 상황마다 총 다운타임 또는 RTO(Recovery Time Objective): 70분

분기당 1회이므로 연간 280분

- 애플리케이션 운영체제 업데이트 연간 6회, 각 4시간

총 28.6시간이므로 99.67%의 가용성 (소수점 둘째 자리 반올림조차 실제 가용성 크게 왜곡시킬 수 있음)

### 99.9%의 가용성을 위한 설계

- 99.9%의 가용성, 연간 9시간의 다운타임 목표
- 이 때의 다운타임은 불편을 넘어서, 큰 위험 요인으로 인식할 수 있는 수준

#### 기본 아키텍처

- 분산 애플리케이션 설계 기법을 활용해야 함
- 애플리케이션은 단일 리전 내, 멀티 AZ 환경에서 멀티 인스턴스 기반으로 실행
- ALB를 이용해 트래픽을 다수의 인스턴스에 분산시키고, 해당 인스턴스에 대한 헬스 체크를 지속적으로 실시
- 지역 템플릿을 이용해 애플리케이션 웹 서버를 설치하고 중앙화 저장소에서 애플리케이션 파일을 복사
- Auto Scaling 그룹을 정성해 3개 AZ마다 2개의 인스턴스, 즉 최소 6개의 인스턴스가 항상 실행되도록 함

**왜 최소 6개의 인스턴스가 필요한가?** 4개의 인스턴스로 피크 타임 트래픽을 처리할 수 있는 경우를 생각해보자. 6개의 인스턴스를 사용하면 1개 AZ가 실패하더라도 2개 AZ의 각각 2개씩 있는 인스턴스를 통해 AZ마다 50%의 피크 트래픽을 처리해 줄 100%의 피크 타임 트래픽을 문제 없이 처리할 수 있음.

#### 데이터베이스 구성

- 멀티 AZ 환경을 구성하고, 멀티 인스턴스를 생성하고, 지역 템플릿을 이용해 애플리케이션 서버를 설치
- 멀티 AZ 기반 RDS 사용
- 자동 데이터베이스 스냅샷 기능을 자동으로 생성되도록 해야 함

#### 백업 및 자동 복구

대부분의 실패 상황에 대한 복원 작업은 자동으로 이뤄짐:

- Auto Scaling 그룹에서 ALB의 타겟 헬스 체크 기능을 이용해 인스턴스의 상태를 확인
- 인스턴스 실패 시 ALB는 해당 인스턴스에 트래픽을 전송하지 않으며, Auto Scaling은 해당 인스턴스를 폐기하고 새 인스턴스를 추가

#### 가용성 계산

- 중복 구성 기법 및 분산 아키텍처 활용
- 애플리케이션 실제 상황: 연간 2회, 각각 60분 지속
- 애플리케이션과 운영체제 업데이트: 연간 10회, 각각 15분
- 총 다운타임: 270분 또는 4.5시간 → 99.95%의 가용성

### 99.99%의 가용성을 위한 설계

- 99.99%의 가용성, 연간 53분의 다운타임 목표
- 기업에 막대한 수익을 가져다주는 비즈니스 애플리케이션이나 사람의 목숨과 직접 연관된 중요 애플리케이션

#### 다중 리전 구성

- AWS는 개별 AZ의 실패를 격리하기 위해 엄청난 투자를 하고 있지만 단일 리전에 있는 다수의 AZ가 실패한 가능성을 완전히 제거할 수는 없음
- 두 개의 리전에 인스턴스를 추가하고 하나는 액티브 리전(active region)으로 다른 하나는 패시브 리전(passive region)으로 운영
- 각 리전마다 멀티 AZ 환경을 구성하고, 멀티 인스턴스를 생성하고, 피크 타임에 각 AZ가 각각 50%의 트래픽을 처리할 수 있도록 함

#### 데이터베이스 고가용성

##### 멀티 AZ RDS의 한계

- 멀티 AZ RDS의 경우 기본 데이터베이스 인스턴스와 보조 데이터베이스 인스턴스가 반드시 동일한 리전에서 실행돼야 함

##### 멀티 리전 읽기 복제본 활용

- MySQL 또는 MariaDB 데이터베이스 엔진의 멀티 AZ 읽기 사본(read replica)을 생성해 다수의 리전에 배포
- 기본 데이터베이스 인스턴스에 기록되는 시점과 읽기 사본에 기록되는 시점의 차이가 존재함
    - 예: 읽기 사본 복제 지연 시간이 10분이라면 이 10분간의 데이터를 잃을 가능성이 있음

#### 장애 복구 절차

##### 자동 vs 수동 복구

- 이전 시나리오에서는 개별 AZ가 실패하더라도 다른 AZ를 이용해 자동으로 복원 작업이 이뤄짐
- 리전 단위 실패의 경우 자동 복원이 힘들어 수동 복원이 수행돼야 함

##### 모니터링 및 페일오버

- CloudWatch Alarm을 생성해 ALB 헬스 체크 모니터링 기능으로 액티브 리전 내 인스턴스의 상태를 확인
- 액티브 리전의 ALB 헬스 체크가 실패한 경우 패시브 리전을 기반으로 한 실패 대응에 나서야 함

**페일오버 작업 과정**

1. Route 53의 리소스 레코드를 수정해 패시브 리전의 ALB로 사용자 트래픽 흐름을 변경
2. 패시브 리전의 읽기 사본을 기본 데이터베이스 인스턴스로 승격

#### 무중단 업데이트

업데이트 작업 시에는 새 인스턴스를 생성해 업데이트를 진행한 뒤 기존 인스턴스를 점진적으로 대체함. 문제 발생 시 사용자 트래픽을 즉각적으로 기존 인스턴스로 되돌려 보냄.

#### 가용성 계산

- 연간 2회의 실패 발생과 실패 대응에 각각 20분이 소요
- 연간 다운타임: 40분 → 99.99%의 가용성

---

**가용성 레벨별 요약**

|가용성|연간 다운타임|주요 구성 요소|복잡도|
|---|---|---|---|
|99%|3.5일|단일 인스턴스 + S3 백업 + Route 53|낮음|
|99.9%|9시간|멀티 AZ + ALB + Auto Scaling|중간|
|99.99%|53분|멀티 리전 + 읽기 복제본 + 무중단 업데이트|높음|

비즈니스 요구사항과 예산을 고려해 적절한 가용성 수준을 선택하는 것이 중요함.

